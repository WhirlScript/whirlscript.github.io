import{_ as t,o as e,c as a,Q as d}from"./chunks/framework.jBbNkKut.js";const g=JSON.parse('{"title":"注解","description":"","frontmatter":{"prev":{"text":"目标限定","link":"/zh/guide/getting-started/target-specify"},"next":false},"headers":[],"relativePath":"zh/guide/getting-started/annotation.md","filePath":"zh/guide/getting-started/annotation.md"}'),o={name:"zh/guide/getting-started/annotation.md"},r=d('<h1 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h1><p>在这之前，我们已经接触了好几种注解了。</p><p>注解是一种特殊注释。更形象的说，注解是给编译器看的注释，它影响着编译器如何处理接下来的语句。</p><p>WhirlScript 的注解分为两种，分别是对语句的注解和对声明的注解。</p><h2 id="语句注解" tabindex="-1">语句注解 <a class="header-anchor" href="#语句注解" aria-label="Permalink to &quot;语句注解&quot;">​</a></h2><p>现有的语句注解包括这些：</p><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td><code>@sh</code></td><td>接下来的语句或语句块只在编译到 sh 脚本时会被解析</td></tr><tr><td><code>@bat</code></td><td>接下来的语句或语句块只在编译到 bat 脚本时会被解析</td></tr></tbody></table><p>其中，<code>@sh</code> 和 <code>@bat</code> 的用法详见 <a href="/zh/guide/getting-started/target-specify">目标限定</a> 。</p><h2 id="声明注解" tabindex="-1">声明注解 <a class="header-anchor" href="#声明注解" aria-label="Permalink to &quot;声明注解&quot;">​</a></h2><p>现有的声明注解包括这些：</p><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td><code>@final</code></td><td>接下来声明的量或函数为最终量，名称在编译结果中不会被修改。</td></tr><tr><td><code>@env</code></td><td>接下来声明的量为环境变量。需要声明为常量。</td></tr><tr><td><code>@editable</code></td><td>接下来声明的量为可编辑变量，编译后将被放在脚本顶端以允许用户编辑。</td></tr></tbody></table>',11),n=[r];function i(h,c,s,l,p,_){return e(),a("div",null,n)}const f=t(o,[["render",i]]);export{g as __pageData,f as default};
