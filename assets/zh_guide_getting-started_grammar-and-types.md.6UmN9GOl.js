import{_ as a,o as s,c as e,Q as n}from"./chunks/framework.jBbNkKut.js";const E=JSON.parse('{"title":"语法和数据类型","description":"","frontmatter":{"prev":{"text":"Hello Whirlpool!","link":"/zh/guide/getting-started/hello-whirlpool"},"next":{"text":"流程控制","link":"/zh/guide/getting-started/control-flow"}},"headers":[],"relativePath":"zh/guide/getting-started/grammar-and-types.md","filePath":"zh/guide/getting-started/grammar-and-types.md"}'),l={name:"zh/guide/getting-started/grammar-and-types.md"},o=n(`<h1 id="语法和数据类型" tabindex="-1">语法和数据类型 <a class="header-anchor" href="#语法和数据类型" aria-label="Permalink to &quot;语法和数据类型&quot;">​</a></h1><p>在这一节中，我们将讨论 WhirlScript 的基本语法和变量声明。</p><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h2><p>WhirlScript 是区分大小写的，并且使用 UNICODE 字符集。</p><p>在 WhirlScript 中，指令被称为语句，并用分号<code>;</code>进行分隔。</p><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><p>WhirlScript 注释的语法和很多语言类似：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">// 单行注释</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">/* 这是</span></span>
<span class="line"><span style="color:#E1E4E8;">   多行注释。</span></span>
<span class="line"><span style="color:#E1E4E8;"> */</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">// 单行注释</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">/* 这是</span></span>
<span class="line"><span style="color:#24292E;">   多行注释。</span></span>
<span class="line"><span style="color:#24292E;"> */</span></span></code></pre></div><p>在代码编译的过程中，这些会被跳过。但是如果你在编译选项中启用 <code>withComment</code>，这些注释都会被包含在输出中。</p><h2 id="声明" tabindex="-1">声明 <a class="header-anchor" href="#声明" aria-label="Permalink to &quot;声明&quot;">​</a></h2><p>WhirlScript 的量有四种状态：</p><ul><li>编译期变量：可以在编译期修改与使用；</li><li>编译期常量：可以在编译期使用，不能被修改；</li><li>运行时变量：可以在运行时修改和使用；</li><li>运行时常量：可以在运行时使用，不能被修改。</li></ul><p>对应的，有四种声明方式：</p><ul><li><code>#var</code>：声明一个编译期变量，可选初始化一个值。</li><li><code>#const</code>：声明一个编译期常量。</li><li><code>var</code>：声明一个运行时变量，可选初始化一个值。</li><li><code>const</code>：声明一个运行时常量。</li></ul><h3 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h3><p>在应用程序中，使用变量来作为值的符号名。变量的名字又叫做标识符，其需要遵守一定的规则。</p><p>一个 WhirlScript 标识符必须以字母开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。</p><p>和其它语言类似，大部分的运算符不能被包含在名称中。不同的是，这几种其它语言可能允许的符号也不被允许：</p><ul><li><code>$</code></li><li><code>_</code></li></ul><details class="details custom-block"><summary>为什么？</summary><p>由于 shell 中变量的标识是 <code>$</code> 符号，你不能将它用作名称。</p><p><code>_</code> 符号被用作标识作用域和其它内部用途，因此也不能被用作名称。</p><p>需要注意的是，这两种符号会被作为普通运算符解析。</p></details><p>同时，使用关键字作为标识符的行为是未定义的。</p><p>合法的标识符示例：<code>Number_hits</code>、<code>temp99</code>。</p><h3 id="声明变量" tabindex="-1">声明变量 <a class="header-anchor" href="#声明变量" aria-label="Permalink to &quot;声明变量&quot;">​</a></h3><p>你可以通过这种方式声明一个变量：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">var num:int = 1;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">var num:int = 1;</span></span></code></pre></div><p>其中，<code>var</code> 标识声明的是一个运行时变量，<code>num</code> 为变量的标识符，<code>:int</code> 标识变量类型为 <code>int</code>，<code>= 1</code> 将此变量初始化为一个值（在这里为 <code>1</code>）。</p><p>如果包含了初始化，那么变量类型是可省的（由编译器推断）。</p><p>在一些情况下，你必须要标明类型才可能得到你想要的结果：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">var aNum:int = 1;</span></span>
<span class="line"><span style="color:#E1E4E8;">var aString:string = aNum;  // 得到 &quot;1&quot;。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">var aNum:int = 1;</span></span>
<span class="line"><span style="color:#24292E;">var aString:string = aNum;  // 得到 &quot;1&quot;。</span></span></code></pre></div><p>这会在<a href="#数据类型的转换">数据类型的转换</a>中提到。</p><p>对于所有的变量（包括编译期和运行时变量），初始化是可选的。</p><h3 id="变量求值" tabindex="-1">变量求值 <a class="header-anchor" href="#变量求值" aria-label="Permalink to &quot;变量求值&quot;">​</a></h3><p>用 <code>var</code> 语句声明的变量，如果没有赋初始值，则访问其值会得到默认值。默认值按类型是不同的。</p><p>如果访问一个未声明的变量会导致报错。</p><h3 id="最终变量" tabindex="-1">最终变量 <a class="header-anchor" href="#最终变量" aria-label="Permalink to &quot;最终变量&quot;">​</a></h3><p>你可以使用 <code>@final</code> 注解声明一个最终量或函数：</p><div class="warning custom-block"><p class="custom-block-title">⚠️ 警告</p><p>你只能将一个运行时量声明为最终量，而不能将编译期量声明为最终量。函数也一样。</p></div><p>注解相关内容详见 <a href="/zh/guide/getting-started/annotation">注解</a> 。</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@final var g:string = &quot;这是一个最终变量&quot;; // 声明一个最终变量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">bat rawln(&quot;echo %g%&quot;);  // 在 bat 中输出 g。</span></span>
<span class="line"><span style="color:#E1E4E8;">sh rawln(&quot;echo $g&quot;);    // 在 sh 中输出 g。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">// 更推荐的写法</span></span>
<span class="line"><span style="color:#E1E4E8;">rawln(\`echo \${g}\`);   // 这不需要判断语法环境，可以直接调用。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">// 或者直接</span></span>
<span class="line"><span style="color:#E1E4E8;">println(g); 内置的 println 函数。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@final var g:string = &quot;这是一个最终变量&quot;; // 声明一个最终变量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">bat rawln(&quot;echo %g%&quot;);  // 在 bat 中输出 g。</span></span>
<span class="line"><span style="color:#24292E;">sh rawln(&quot;echo $g&quot;);    // 在 sh 中输出 g。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 更推荐的写法</span></span>
<span class="line"><span style="color:#24292E;">rawln(\`echo \${g}\`);   // 这不需要判断语法环境，可以直接调用。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 或者直接</span></span>
<span class="line"><span style="color:#24292E;">println(g); 内置的 println 函数。</span></span></code></pre></div><p>最终量并不会在编译后被修改标识符。也就是说，你可以在 <code>raw</code> 语句中直接调用。但是我们更建议使用模板语法直接拼接命令。</p><h3 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h3><p>你可以用关键字 <code>const</code> 创建一个只读的常量。常量标识符的命名规则和变量相同。</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">const version = &quot;1.1.0&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">const version = &quot;1.1.0&quot;;</span></span></code></pre></div><p>所有的常量（包括编译期和运行时常量）都不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。</p><p>你可以选择缺省类型（由编译器推断）或者显示标明。</p><p>在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。</p><h2 id="数据结构和类型" tabindex="-1">数据结构和类型 <a class="header-anchor" href="#数据结构和类型" aria-label="Permalink to &quot;数据结构和类型&quot;">​</a></h2><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><p>WhirlScript 定义了三种数据类型：</p><ul><li><code>boolean</code>：布尔值，有 2 个值分别是：<code>true</code> 和 <code>false</code>。</li><li><code>int</code>：整数，例如 <code>0</code>、<code>42</code>、<code>1000</code>。</li><li><code>string</code>：字符串，例如 <code>&quot;string&quot;</code>。</li></ul><details class="details custom-block"><summary>为什么没有浮点数？</summary><p>bat 只提供整数的运算。为了兼容，我们只能舍弃这一部分。</p><p>如果您需要得到几位小数，请将除数和被除数同时乘上 10 的 n 次方后，截取尾部。</p><p>shell 提供了对浮点数的支持。如果您需要使用，请在 <code>raw</code> 语句中使用。</p></details><h3 id="数据类型的转换" tabindex="-1">数据类型的转换 <a class="header-anchor" href="#数据类型的转换" aria-label="Permalink to &quot;数据类型的转换&quot;">​</a></h3><p>WhirlScript 是静态类型的，这意味着变量的类型是不可变的。</p><p>例如，你不能通过这种方式给 <code>int</code> 类型变量赋一个 <code>string</code> 值：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">var n:int = 12;</span></span>
<span class="line"><span style="color:#E1E4E8;">n = &quot;string&quot;;   // 报错！</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">var n:int = 12;</span></span>
<span class="line"><span style="color:#24292E;">n = &quot;string&quot;;   // 报错！</span></span></code></pre></div><h4 id="隐式转换" tabindex="-1">隐式转换 <a class="header-anchor" href="#隐式转换" aria-label="Permalink to &quot;隐式转换&quot;">​</a></h4><p>在这种情况下并不会报错：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">var s:string = &quot;string&quot;;</span></span>
<span class="line"><span style="color:#E1E4E8;">s = 12;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">var s:string = &quot;string&quot;;</span></span>
<span class="line"><span style="color:#24292E;">s = 12;</span></span></code></pre></div><p>这里发生了隐式转换。隐式转换有三种情况，分别为：</p><ul><li>布尔值转整数：<code>false</code> 会转换为 <code>0</code>，<code>true</code> 会转换为 <code>1</code>。</li><li>布尔值转字符串：<code>false</code> 会转换为 <code>&quot;0&quot;</code>，<code>true</code> 会转换为 <code>&quot;1&quot;</code>。</li><li>整数转字符串：例如，<code>123</code> 会被转换为 <code>&quot;123&quot;</code>。</li></ul><p>即使在 <code>raw</code> 语句中直接调用，也会这样。</p><details class="details custom-block"><summary>为什么？</summary><p>在底层实现中，所有量都是字符串。</p><p>布尔值的底层实现就是 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>。</p><p>整数的底层实现就是对应的字符串。</p></details><h4 id="类型断言" tabindex="-1">类型断言 <a class="header-anchor" href="#类型断言" aria-label="Permalink to &quot;类型断言&quot;">​</a></h4><p>隐式转换只能向上转换。</p><p>如果你需要反过来转换，则需要类型断言。前提是，你<strong>非常确定</strong>这是可以转换的。</p><p>类型断言使用 <code>&lt;&gt;</code> 来标识，比如：</p><div class="language-whirlscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">whirlscript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">var n:int = &lt;int&gt;&quot;123&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">var n:int = &lt;int&gt;&quot;123&quot;;</span></span></code></pre></div><p>编译器不会检查你的转换是否合法。请<strong>谨慎</strong>使用。</p><h2 id="字面量" tabindex="-1">字面量 <a class="header-anchor" href="#字面量" aria-label="Permalink to &quot;字面量&quot;">​</a></h2><p>在 WhirlScript 中，你可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。</p><p>例如 <code>1</code>、<code>true</code>、<code>&quot;str&quot;</code>。</p>`,71),p=[o];function t(c,i,r,d,h,u){return s(),e("div",null,p)}const q=a(l,[["render",t]]);export{E as __pageData,q as default};
